/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl1.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MSatGrammarAccess extends AbstractGrammarElementFinder {
	
	public class SATMorphicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.SATMorphic");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSolverKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSolversAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSolversSATSolverParserRuleCall_1_0 = (RuleCall)cSolversAssignment_1.eContents().get(0);
		private final Assignment cBenchmarkAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBenchmarkBenchmarkParserRuleCall_2_0 = (RuleCall)cBenchmarkAssignment_2.eContents().get(0);
		
		//SATMorphic:
		//	'solver' solvers+=SATSolver+
		//	benchmark=Benchmark;
		@Override public ParserRule getRule() { return rule; }
		
		//'solver' solvers+=SATSolver+ benchmark=Benchmark
		public Group getGroup() { return cGroup; }
		
		//'solver'
		public Keyword getSolverKeyword_0() { return cSolverKeyword_0; }
		
		//solvers+=SATSolver+
		public Assignment getSolversAssignment_1() { return cSolversAssignment_1; }
		
		//SATSolver
		public RuleCall getSolversSATSolverParserRuleCall_1_0() { return cSolversSATSolverParserRuleCall_1_0; }
		
		//benchmark=Benchmark
		public Assignment getBenchmarkAssignment_2() { return cBenchmarkAssignment_2; }
		
		//Benchmark
		public RuleCall getBenchmarkBenchmarkParserRuleCall_2_0() { return cBenchmarkBenchmarkParserRuleCall_2_0; }
	}
	public class SATSolverElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.SATSolver");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSolverAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cSolverAlternatives_0_0 = (Alternatives)cSolverAssignment_0.eContents().get(0);
		private final RuleCall cSolverSat4JParserRuleCall_0_0_0 = (RuleCall)cSolverAlternatives_0_0.eContents().get(0);
		private final RuleCall cSolverCryptoMiniSATParserRuleCall_0_0_1 = (RuleCall)cSolverAlternatives_0_0.eContents().get(1);
		private final RuleCall cSolverMiniSATParserRuleCall_0_0_2 = (RuleCall)cSolverAlternatives_0_0.eContents().get(2);
		private final Assignment cVersionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVersionSolverVersionParserRuleCall_1_0 = (RuleCall)cVersionAssignment_1.eContents().get(0);
		
		//SATSolver:
		//	solver=(Sat4J | CryptoMiniSAT | MiniSAT) version=SolverVersion?;
		@Override public ParserRule getRule() { return rule; }
		
		//solver=(Sat4J | CryptoMiniSAT | MiniSAT) version=SolverVersion?
		public Group getGroup() { return cGroup; }
		
		//solver=(Sat4J | CryptoMiniSAT | MiniSAT)
		public Assignment getSolverAssignment_0() { return cSolverAssignment_0; }
		
		//(Sat4J | CryptoMiniSAT | MiniSAT)
		public Alternatives getSolverAlternatives_0_0() { return cSolverAlternatives_0_0; }
		
		//Sat4J
		public RuleCall getSolverSat4JParserRuleCall_0_0_0() { return cSolverSat4JParserRuleCall_0_0_0; }
		
		//CryptoMiniSAT
		public RuleCall getSolverCryptoMiniSATParserRuleCall_0_0_1() { return cSolverCryptoMiniSATParserRuleCall_0_0_1; }
		
		//MiniSAT
		public RuleCall getSolverMiniSATParserRuleCall_0_0_2() { return cSolverMiniSATParserRuleCall_0_0_2; }
		
		//version=SolverVersion?
		public Assignment getVersionAssignment_1() { return cVersionAssignment_1; }
		
		//SolverVersion
		public RuleCall getVersionSolverVersionParserRuleCall_1_0() { return cVersionSolverVersionParserRuleCall_1_0; }
	}
	public class Sat4JElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.Sat4J");
		private final Assignment cVariantAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cVariantSat4JVariantEnumRuleCall_0 = (RuleCall)cVariantAssignment.eContents().get(0);
		
		//Sat4J:
		//	variant=Sat4JVariant;
		@Override public ParserRule getRule() { return rule; }
		
		//variant=Sat4JVariant
		public Assignment getVariantAssignment() { return cVariantAssignment; }
		
		//Sat4JVariant
		public RuleCall getVariantSat4JVariantEnumRuleCall_0() { return cVariantSat4JVariantEnumRuleCall_0; }
	}
	public class SolverVersionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.SolverVersion");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVersionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVersionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVersionSTRINGTerminalRuleCall_1_0 = (RuleCall)cVersionAssignment_1.eContents().get(0);
		
		//SolverVersion:
		//	"version" version=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//"version" version=STRING
		public Group getGroup() { return cGroup; }
		
		//"version"
		public Keyword getVersionKeyword_0() { return cVersionKeyword_0; }
		
		//version=STRING
		public Assignment getVersionAssignment_1() { return cVersionAssignment_1; }
		
		//STRING
		public RuleCall getVersionSTRINGTerminalRuleCall_1_0() { return cVersionSTRINGTerminalRuleCall_1_0; }
	}
	public class MiniSATElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.MiniSAT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariantAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cVariantMinisatKeyword_0_0 = (Keyword)cVariantAssignment_0.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParameterMiniSATParameterParserRuleCall_1_0 = (RuleCall)cParameterAssignment_1.eContents().get(0);
		
		//MiniSAT:
		//	variant="minisat" parameter=MiniSATParameter?;
		@Override public ParserRule getRule() { return rule; }
		
		//variant="minisat" parameter=MiniSATParameter?
		public Group getGroup() { return cGroup; }
		
		//variant="minisat"
		public Assignment getVariantAssignment_0() { return cVariantAssignment_0; }
		
		//"minisat"
		public Keyword getVariantMinisatKeyword_0_0() { return cVariantMinisatKeyword_0_0; }
		
		//parameter=MiniSATParameter?
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }
		
		//MiniSATParameter
		public RuleCall getParameterMiniSATParameterParserRuleCall_1_0() { return cParameterMiniSATParameterParserRuleCall_1_0; }
	}
	public class CryptoMiniSATElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.CryptoMiniSAT");
		private final Assignment cVariantAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cVariantCryptominisatKeyword_0 = (Keyword)cVariantAssignment.eContents().get(0);
		
		//CryptoMiniSAT:
		//	variant="cryptominisat";
		@Override public ParserRule getRule() { return rule; }
		
		//variant="cryptominisat"
		public Assignment getVariantAssignment() { return cVariantAssignment; }
		
		//"cryptominisat"
		public Keyword getVariantCryptominisatKeyword_0() { return cVariantCryptominisatKeyword_0; }
	}
	public class MiniSATParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.MiniSATParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRndFreqKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRndfreqAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRndfreqPROBATerminalRuleCall_1_0 = (RuleCall)cRndfreqAssignment_1.eContents().get(0);
		
		//// https://www.msoos.org/minisat-faq/
		//MiniSATParameter:
		//	'rnd-freq' rndfreq=PROBA;
		@Override public ParserRule getRule() { return rule; }
		
		//'rnd-freq' rndfreq=PROBA
		public Group getGroup() { return cGroup; }
		
		//'rnd-freq'
		public Keyword getRndFreqKeyword_0() { return cRndFreqKeyword_0; }
		
		//rndfreq=PROBA
		public Assignment getRndfreqAssignment_1() { return cRndfreqAssignment_1; }
		
		//PROBA
		public RuleCall getRndfreqPROBATerminalRuleCall_1_0() { return cRndfreqPROBATerminalRuleCall_1_0; }
	}
	public class BenchmarkElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.Benchmark");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBenchmarkDimacsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBenchmarkFormulaParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Benchmark:
		//	BenchmarkDimacs | BenchmarkFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//BenchmarkDimacs | BenchmarkFormula
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BenchmarkDimacs
		public RuleCall getBenchmarkDimacsParserRuleCall_0() { return cBenchmarkDimacsParserRuleCall_0; }
		
		//BenchmarkFormula
		public RuleCall getBenchmarkFormulaParserRuleCall_1() { return cBenchmarkFormulaParserRuleCall_1; }
	}
	public class BenchmarkDimacsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.BenchmarkDimacs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBenchmarkDIMACSKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cDimacsesAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cDimacsesSTRINGTerminalRuleCall_1_0_0 = (RuleCall)cDimacsesAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cDimacsesAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cDimacsesSTRINGTerminalRuleCall_1_1_1_0 = (RuleCall)cDimacsesAssignment_1_1_1.eContents().get(0);
		
		//BenchmarkDimacs:
		//	'benchmarkDIMACS' (dimacses+=STRING ("," dimacses+=STRING)*);
		@Override public ParserRule getRule() { return rule; }
		
		//'benchmarkDIMACS' (dimacses+=STRING ("," dimacses+=STRING)*)
		public Group getGroup() { return cGroup; }
		
		//'benchmarkDIMACS'
		public Keyword getBenchmarkDIMACSKeyword_0() { return cBenchmarkDIMACSKeyword_0; }
		
		//(dimacses+=STRING ("," dimacses+=STRING)*)
		public Group getGroup_1() { return cGroup_1; }
		
		//dimacses+=STRING
		public Assignment getDimacsesAssignment_1_0() { return cDimacsesAssignment_1_0; }
		
		//STRING
		public RuleCall getDimacsesSTRINGTerminalRuleCall_1_0_0() { return cDimacsesSTRINGTerminalRuleCall_1_0_0; }
		
		//("," dimacses+=STRING)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }
		
		//dimacses+=STRING
		public Assignment getDimacsesAssignment_1_1_1() { return cDimacsesAssignment_1_1_1; }
		
		//STRING
		public RuleCall getDimacsesSTRINGTerminalRuleCall_1_1_1_0() { return cDimacsesSTRINGTerminalRuleCall_1_1_1_0; }
	}
	public class BenchmarkFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.BenchmarkFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBenchmarkFormulaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionsBiImplParserRuleCall_1_0_0 = (RuleCall)cExpressionsAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cExpressionsBiImplParserRuleCall_1_1_1_0 = (RuleCall)cExpressionsAssignment_1_1_1.eContents().get(0);
		
		//BenchmarkFormula:
		//	'benchmarkFormula' (expressions+=BiImpl ("," expressions+=BiImpl)*);
		@Override public ParserRule getRule() { return rule; }
		
		//'benchmarkFormula' (expressions+=BiImpl ("," expressions+=BiImpl)*)
		public Group getGroup() { return cGroup; }
		
		//'benchmarkFormula'
		public Keyword getBenchmarkFormulaKeyword_0() { return cBenchmarkFormulaKeyword_0; }
		
		//(expressions+=BiImpl ("," expressions+=BiImpl)*)
		public Group getGroup_1() { return cGroup_1; }
		
		//expressions+=BiImpl
		public Assignment getExpressionsAssignment_1_0() { return cExpressionsAssignment_1_0; }
		
		//BiImpl
		public RuleCall getExpressionsBiImplParserRuleCall_1_0_0() { return cExpressionsBiImplParserRuleCall_1_0_0; }
		
		//("," expressions+=BiImpl)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }
		
		//expressions+=BiImpl
		public Assignment getExpressionsAssignment_1_1_1() { return cExpressionsAssignment_1_1_1; }
		
		//BiImpl
		public RuleCall getExpressionsBiImplParserRuleCall_1_1_1_0() { return cExpressionsBiImplParserRuleCall_1_1_1_0; }
	}
	public class BiImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.BiImpl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImplParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBiImplLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightImplParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BiImpl Expression:
		//	Impl ({BiImpl.left=current} '<=>' right=Impl)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Impl ({BiImpl.left=current} '<=>' right=Impl)*
		public Group getGroup() { return cGroup; }
		
		//Impl
		public RuleCall getImplParserRuleCall_0() { return cImplParserRuleCall_0; }
		
		//({BiImpl.left=current} '<=>' right=Impl)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BiImpl.left=current}
		public Action getBiImplLeftAction_1_0() { return cBiImplLeftAction_1_0; }
		
		//'<=>'
		public Keyword getLessThanSignEqualsSignGreaterThanSignKeyword_1_1() { return cLessThanSignEqualsSignGreaterThanSignKeyword_1_1; }
		
		//right=Impl
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Impl
		public RuleCall getRightImplParserRuleCall_1_2_0() { return cRightImplParserRuleCall_1_2_0; }
	}
	public class ImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.Impl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImplLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Impl Expression:
		//	Or ({Impl.left=current} '=>' right=Or)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({Impl.left=current} '=>' right=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({Impl.left=current} '=>' right=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Impl.left=current}
		public Action getImplLeftAction_1_0() { return cImplLeftAction_1_0; }
		
		//'=>'
		public Keyword getEqualsSignGreaterThanSignKeyword_1_1() { return cEqualsSignGreaterThanSignKeyword_1_1; }
		
		//right=Or
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Or
		public RuleCall getRightOrParserRuleCall_1_2_0() { return cRightOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.left=current} 'v' right=And)*;
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} 'v' right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} 'v' right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'v'
		public Keyword getVKeyword_1_1() { return cVKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNandParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightNandParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Expression:
		//	Nand ({And.left=current} '^' right=Nand)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Nand ({And.left=current} '^' right=Nand)*
		public Group getGroup() { return cGroup; }
		
		//Nand
		public RuleCall getNandParserRuleCall_0() { return cNandParserRuleCall_0; }
		
		//({And.left=current} '^' right=Nand)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1_1() { return cCircumflexAccentKeyword_1_1; }
		
		//right=Nand
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Nand
		public RuleCall getRightNandParserRuleCall_1_2_0() { return cRightNandParserRuleCall_1_2_0; }
	}
	public class NandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.Nand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNandLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cVerticalLineKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cUpwardsArrowKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Nand Expression:
		//	Primary ({Nand.left=current} ('|' | '↑') right=Primary)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({Nand.left=current} ('|' | '↑') right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({Nand.left=current} ('|' | '↑') right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Nand.left=current}
		public Action getNandLeftAction_1_0() { return cNandLeftAction_1_0; }
		
		//('|' | '↑')
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//'|'
		public Keyword getVerticalLineKeyword_1_1_0() { return cVerticalLineKeyword_1_1_0; }
		
		//'↑'
		public Keyword getUpwardsArrowKeyword_1_1_1() { return cUpwardsArrowKeyword_1_1_1; }
		
		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cBiImplParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cNotParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVarParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Primary Expression:
		//	'(' BiImpl ')' | Not | Const | Var;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' BiImpl ')' | Not | Const | Var
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' BiImpl ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//BiImpl
		public RuleCall getBiImplParserRuleCall_0_1() { return cBiImplParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//Not
		public RuleCall getNotParserRuleCall_1() { return cNotParserRuleCall_1; }
		
		//Const
		public RuleCall getConstParserRuleCall_2() { return cConstParserRuleCall_2; }
		
		//Var
		public RuleCall getVarParserRuleCall_3() { return cVarParserRuleCall_3; }
	}
	public class NotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.Not");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cTildeKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Action cNotExpressionAction_2 = (Action)cGroup.eContents().get(2);
		
		//Not Expression:
		//	('!' | '~') Primary {Not.expression=current};
		@Override public ParserRule getRule() { return rule; }
		
		//('!' | '~') Primary {Not.expression=current}
		public Group getGroup() { return cGroup; }
		
		//('!' | '~')
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_0_0() { return cExclamationMarkKeyword_0_0; }
		
		//'~'
		public Keyword getTildeKeyword_0_1() { return cTildeKeyword_0_1; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_1() { return cPrimaryParserRuleCall_1; }
		
		//{Not.expression=current}
		public Action getNotExpressionAction_2() { return cNotExpressionAction_2; }
	}
	public class VarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.Var");
		private final Assignment cIdAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdIDTerminalRuleCall_0 = (RuleCall)cIdAssignment.eContents().get(0);
		
		//Var Expression:
		//	id=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//id=ID
		public Assignment getIdAssignment() { return cIdAssignment; }
		
		//ID
		public RuleCall getIdIDTerminalRuleCall_0() { return cIdIDTerminalRuleCall_0; }
	}
	public class ConstElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.Const");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cValAlternatives_0 = (Alternatives)cValAssignment.eContents().get(0);
		private final Keyword cValTrueKeyword_0_0 = (Keyword)cValAlternatives_0.eContents().get(0);
		private final Keyword cValFalseKeyword_0_1 = (Keyword)cValAlternatives_0.eContents().get(1);
		
		//Const Expression:
		//	val=("true" | "false");
		@Override public ParserRule getRule() { return rule; }
		
		//val=("true" | "false")
		public Assignment getValAssignment() { return cValAssignment; }
		
		//("true" | "false")
		public Alternatives getValAlternatives_0() { return cValAlternatives_0; }
		
		//"true"
		public Keyword getValTrueKeyword_0_0() { return cValTrueKeyword_0_0; }
		
		//"false"
		public Keyword getValFalseKeyword_0_1() { return cValFalseKeyword_0_1; }
	}
	
	public class Sat4JVariantElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.Sat4JVariant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSAT4J_JAVAEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSAT4J_JAVASat4jJavaKeyword_0_0 = (Keyword)cSAT4J_JAVAEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSAT4J_JAREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSAT4J_JARSat4jJarKeyword_1_0 = (Keyword)cSAT4J_JAREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cSAT4J_COMPEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cSAT4J_COMPSat4jMavenKeyword_2_0 = (Keyword)cSAT4J_COMPEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum Sat4JVariant:
		//	SAT4J_JAVA="sat4j-java" | SAT4J_JAR="sat4j-jar" | SAT4J_COMP="sat4j-maven";
		public EnumRule getRule() { return rule; }
		
		//SAT4J_JAVA="sat4j-java" | SAT4J_JAR="sat4j-jar" | SAT4J_COMP="sat4j-maven"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SAT4J_JAVA="sat4j-java"
		public EnumLiteralDeclaration getSAT4J_JAVAEnumLiteralDeclaration_0() { return cSAT4J_JAVAEnumLiteralDeclaration_0; }
		
		//"sat4j-java"
		public Keyword getSAT4J_JAVASat4jJavaKeyword_0_0() { return cSAT4J_JAVASat4jJavaKeyword_0_0; }
		
		//SAT4J_JAR="sat4j-jar"
		public EnumLiteralDeclaration getSAT4J_JAREnumLiteralDeclaration_1() { return cSAT4J_JAREnumLiteralDeclaration_1; }
		
		//"sat4j-jar"
		public Keyword getSAT4J_JARSat4jJarKeyword_1_0() { return cSAT4J_JARSat4jJarKeyword_1_0; }
		
		//SAT4J_COMP="sat4j-maven"
		public EnumLiteralDeclaration getSAT4J_COMPEnumLiteralDeclaration_2() { return cSAT4J_COMPEnumLiteralDeclaration_2; }
		
		//"sat4j-maven"
		public Keyword getSAT4J_COMPSat4jMavenKeyword_2_0() { return cSAT4J_COMPSat4jMavenKeyword_2_0; }
	}
	
	private final SATMorphicElements pSATMorphic;
	private final SATSolverElements pSATSolver;
	private final Sat4JElements pSat4J;
	private final Sat4JVariantElements eSat4JVariant;
	private final SolverVersionElements pSolverVersion;
	private final MiniSATElements pMiniSAT;
	private final CryptoMiniSATElements pCryptoMiniSAT;
	private final MiniSATParameterElements pMiniSATParameter;
	private final TerminalRule tPROBA;
	private final BenchmarkElements pBenchmark;
	private final BenchmarkDimacsElements pBenchmarkDimacs;
	private final BenchmarkFormulaElements pBenchmarkFormula;
	private final BiImplElements pBiImpl;
	private final ImplElements pImpl;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final NandElements pNand;
	private final PrimaryElements pPrimary;
	private final NotElements pNot;
	private final VarElements pVar;
	private final ConstElements pConst;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MSatGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pSATMorphic = new SATMorphicElements();
		this.pSATSolver = new SATSolverElements();
		this.pSat4J = new Sat4JElements();
		this.eSat4JVariant = new Sat4JVariantElements();
		this.pSolverVersion = new SolverVersionElements();
		this.pMiniSAT = new MiniSATElements();
		this.pCryptoMiniSAT = new CryptoMiniSATElements();
		this.pMiniSATParameter = new MiniSATParameterElements();
		this.tPROBA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl1.MSat.PROBA");
		this.pBenchmark = new BenchmarkElements();
		this.pBenchmarkDimacs = new BenchmarkDimacsElements();
		this.pBenchmarkFormula = new BenchmarkFormulaElements();
		this.pBiImpl = new BiImplElements();
		this.pImpl = new ImplElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pNand = new NandElements();
		this.pPrimary = new PrimaryElements();
		this.pNot = new NotElements();
		this.pVar = new VarElements();
		this.pConst = new ConstElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.mydsl1.MSat".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//SATMorphic:
	//	'solver' solvers+=SATSolver+
	//	benchmark=Benchmark;
	public SATMorphicElements getSATMorphicAccess() {
		return pSATMorphic;
	}
	
	public ParserRule getSATMorphicRule() {
		return getSATMorphicAccess().getRule();
	}
	
	//SATSolver:
	//	solver=(Sat4J | CryptoMiniSAT | MiniSAT) version=SolverVersion?;
	public SATSolverElements getSATSolverAccess() {
		return pSATSolver;
	}
	
	public ParserRule getSATSolverRule() {
		return getSATSolverAccess().getRule();
	}
	
	//Sat4J:
	//	variant=Sat4JVariant;
	public Sat4JElements getSat4JAccess() {
		return pSat4J;
	}
	
	public ParserRule getSat4JRule() {
		return getSat4JAccess().getRule();
	}
	
	//enum Sat4JVariant:
	//	SAT4J_JAVA="sat4j-java" | SAT4J_JAR="sat4j-jar" | SAT4J_COMP="sat4j-maven";
	public Sat4JVariantElements getSat4JVariantAccess() {
		return eSat4JVariant;
	}
	
	public EnumRule getSat4JVariantRule() {
		return getSat4JVariantAccess().getRule();
	}
	
	//SolverVersion:
	//	"version" version=STRING;
	public SolverVersionElements getSolverVersionAccess() {
		return pSolverVersion;
	}
	
	public ParserRule getSolverVersionRule() {
		return getSolverVersionAccess().getRule();
	}
	
	//MiniSAT:
	//	variant="minisat" parameter=MiniSATParameter?;
	public MiniSATElements getMiniSATAccess() {
		return pMiniSAT;
	}
	
	public ParserRule getMiniSATRule() {
		return getMiniSATAccess().getRule();
	}
	
	//CryptoMiniSAT:
	//	variant="cryptominisat";
	public CryptoMiniSATElements getCryptoMiniSATAccess() {
		return pCryptoMiniSAT;
	}
	
	public ParserRule getCryptoMiniSATRule() {
		return getCryptoMiniSATAccess().getRule();
	}
	
	//// https://www.msoos.org/minisat-faq/
	//MiniSATParameter:
	//	'rnd-freq' rndfreq=PROBA;
	public MiniSATParameterElements getMiniSATParameterAccess() {
		return pMiniSATParameter;
	}
	
	public ParserRule getMiniSATParameterRule() {
		return getMiniSATParameterAccess().getRule();
	}
	
	//terminal PROBA returns ecore::EFloat:
	//	'1' | '0' (. INT)?;
	public TerminalRule getPROBARule() {
		return tPROBA;
	}
	
	//Benchmark:
	//	BenchmarkDimacs | BenchmarkFormula;
	public BenchmarkElements getBenchmarkAccess() {
		return pBenchmark;
	}
	
	public ParserRule getBenchmarkRule() {
		return getBenchmarkAccess().getRule();
	}
	
	//BenchmarkDimacs:
	//	'benchmarkDIMACS' (dimacses+=STRING ("," dimacses+=STRING)*);
	public BenchmarkDimacsElements getBenchmarkDimacsAccess() {
		return pBenchmarkDimacs;
	}
	
	public ParserRule getBenchmarkDimacsRule() {
		return getBenchmarkDimacsAccess().getRule();
	}
	
	//BenchmarkFormula:
	//	'benchmarkFormula' (expressions+=BiImpl ("," expressions+=BiImpl)*);
	public BenchmarkFormulaElements getBenchmarkFormulaAccess() {
		return pBenchmarkFormula;
	}
	
	public ParserRule getBenchmarkFormulaRule() {
		return getBenchmarkFormulaAccess().getRule();
	}
	
	//BiImpl Expression:
	//	Impl ({BiImpl.left=current} '<=>' right=Impl)*;
	public BiImplElements getBiImplAccess() {
		return pBiImpl;
	}
	
	public ParserRule getBiImplRule() {
		return getBiImplAccess().getRule();
	}
	
	//Impl Expression:
	//	Or ({Impl.left=current} '=>' right=Or)*;
	public ImplElements getImplAccess() {
		return pImpl;
	}
	
	public ParserRule getImplRule() {
		return getImplAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.left=current} 'v' right=And)*;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Expression:
	//	Nand ({And.left=current} '^' right=Nand)*;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Nand Expression:
	//	Primary ({Nand.left=current} ('|' | '↑') right=Primary)*;
	public NandElements getNandAccess() {
		return pNand;
	}
	
	public ParserRule getNandRule() {
		return getNandAccess().getRule();
	}
	
	//Primary Expression:
	//	'(' BiImpl ')' | Not | Const | Var;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//Not Expression:
	//	('!' | '~') Primary {Not.expression=current};
	public NotElements getNotAccess() {
		return pNot;
	}
	
	public ParserRule getNotRule() {
		return getNotAccess().getRule();
	}
	
	//Var Expression:
	//	id=ID;
	public VarElements getVarAccess() {
		return pVar;
	}
	
	public ParserRule getVarRule() {
		return getVarAccess().getRule();
	}
	
	//Const Expression:
	//	val=("true" | "false");
	public ConstElements getConstAccess() {
		return pConst;
	}
	
	public ParserRule getConstRule() {
		return getConstAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
