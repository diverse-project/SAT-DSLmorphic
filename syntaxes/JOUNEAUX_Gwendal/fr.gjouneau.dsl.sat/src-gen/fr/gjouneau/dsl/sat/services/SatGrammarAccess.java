/*
 * generated by Xtext 2.19.0
 */
package fr.gjouneau.dsl.sat.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SatGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelSATElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.gjouneau.dsl.sat.Sat.ModelSAT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModelSATAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0_0 = (RuleCall)cExpressionAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cExpressionAssignment_1_1_1.eContents().get(0);
		
		//ModelSAT:
		//	{ModelSAT} (expression+=Expression (";" expression+=Expression)*)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{ModelSAT} (expression+=Expression (";" expression+=Expression)*)?
		public Group getGroup() { return cGroup; }
		
		//{ModelSAT}
		public Action getModelSATAction_0() { return cModelSATAction_0; }
		
		//(expression+=Expression (";" expression+=Expression)*)?
		public Group getGroup_1() { return cGroup_1; }
		
		//expression+=Expression
		public Assignment getExpressionAssignment_1_0() { return cExpressionAssignment_1_0; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0_0() { return cExpressionExpressionParserRuleCall_1_0_0; }
		
		//(";" expression+=Expression)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//";"
		public Keyword getSemicolonKeyword_1_1_0() { return cSemicolonKeyword_1_1_0; }
		
		//expression+=Expression
		public Assignment getExpressionAssignment_1_1_1() { return cExpressionAssignment_1_1_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_1_0() { return cExpressionExpressionParserRuleCall_1_1_1_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.gjouneau.dsl.sat.Sat.Expression");
		private final RuleCall cEquivParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	Equiv;
		@Override public ParserRule getRule() { return rule; }
		
		//Equiv
		public RuleCall getEquivParserRuleCall() { return cEquivParserRuleCall; }
	}
	public class EquivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.gjouneau.dsl.sat.Sat.Equiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImpliesParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEquivLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cEQUIVKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignGreaterThanSignKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsImpliesParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//Equiv Expression:
		//	Implies ({Equiv.lhs=current} ("EQUIV" | "<=>") rhs=Implies)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Implies ({Equiv.lhs=current} ("EQUIV" | "<=>") rhs=Implies)*
		public Group getGroup() { return cGroup; }
		
		//Implies
		public RuleCall getImpliesParserRuleCall_0() { return cImpliesParserRuleCall_0; }
		
		//({Equiv.lhs=current} ("EQUIV" | "<=>") rhs=Implies)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Equiv.lhs=current}
		public Action getEquivLhsAction_1_0() { return cEquivLhsAction_1_0; }
		
		//("EQUIV" | "<=>")
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//"EQUIV"
		public Keyword getEQUIVKeyword_1_1_0() { return cEQUIVKeyword_1_1_0; }
		
		//"<=>"
		public Keyword getLessThanSignEqualsSignGreaterThanSignKeyword_1_1_1() { return cLessThanSignEqualsSignGreaterThanSignKeyword_1_1_1; }
		
		//rhs=Implies
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//Implies
		public RuleCall getRhsImpliesParserRuleCall_1_2_0() { return cRhsImpliesParserRuleCall_1_2_0; }
	}
	public class ImpliesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.gjouneau.dsl.sat.Sat.Implies");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImpliesLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cIMPLIESKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsOrParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//Implies Expression:
		//	Or ({Implies.lhs=current} ("IMPLIES" | "->") rhs=Or)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({Implies.lhs=current} ("IMPLIES" | "->") rhs=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({Implies.lhs=current} ("IMPLIES" | "->") rhs=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Implies.lhs=current}
		public Action getImpliesLhsAction_1_0() { return cImpliesLhsAction_1_0; }
		
		//("IMPLIES" | "->")
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//"IMPLIES"
		public Keyword getIMPLIESKeyword_1_1_0() { return cIMPLIESKeyword_1_1_0; }
		
		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_1_1() { return cHyphenMinusGreaterThanSignKeyword_1_1_1; }
		
		//rhs=Or
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//Or
		public RuleCall getRhsOrParserRuleCall_1_2_0() { return cRhsOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.gjouneau.dsl.sat.Sat.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cORKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsAndParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.lhs=current} ("OR" | "||") rhs=And)*;
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.lhs=current} ("OR" | "||") rhs=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.lhs=current} ("OR" | "||") rhs=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.lhs=current}
		public Action getOrLhsAction_1_0() { return cOrLhsAction_1_0; }
		
		//("OR" | "||")
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//"OR"
		public Keyword getORKeyword_1_1_0() { return cORKeyword_1_1_0; }
		
		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1_1() { return cVerticalLineVerticalLineKeyword_1_1_1; }
		
		//rhs=And
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//And
		public RuleCall getRhsAndParserRuleCall_1_2_0() { return cRhsAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.gjouneau.dsl.sat.Sat.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNandParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cANDKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsNandParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//And Expression:
		//	Nand ({And.lhs=current} ("AND" | "&&") rhs=Nand)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Nand ({And.lhs=current} ("AND" | "&&") rhs=Nand)*
		public Group getGroup() { return cGroup; }
		
		//Nand
		public RuleCall getNandParserRuleCall_0() { return cNandParserRuleCall_0; }
		
		//({And.lhs=current} ("AND" | "&&") rhs=Nand)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.lhs=current}
		public Action getAndLhsAction_1_0() { return cAndLhsAction_1_0; }
		
		//("AND" | "&&")
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//"AND"
		public Keyword getANDKeyword_1_1_0() { return cANDKeyword_1_1_0; }
		
		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1_1() { return cAmpersandAmpersandKeyword_1_1_1; }
		
		//rhs=Nand
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//Nand
		public RuleCall getRhsNandParserRuleCall_1_2_0() { return cRhsNandParserRuleCall_1_2_0; }
	}
	public class NandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.gjouneau.dsl.sat.Sat.Nand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNandLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cNANDKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cExclamationMarkAmpersandKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsPrimaryParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//Nand Expression:
		//	Primary ({Nand.lhs=current} ("NAND" | "!&") rhs=Primary)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({Nand.lhs=current} ("NAND" | "!&") rhs=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({Nand.lhs=current} ("NAND" | "!&") rhs=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Nand.lhs=current}
		public Action getNandLhsAction_1_0() { return cNandLhsAction_1_0; }
		
		//("NAND" | "!&")
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//"NAND"
		public Keyword getNANDKeyword_1_1_0() { return cNANDKeyword_1_1_0; }
		
		//"!&"
		public Keyword getExclamationMarkAmpersandKeyword_1_1_1() { return cExclamationMarkAmpersandKeyword_1_1_1; }
		
		//rhs=Primary
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//Primary
		public RuleCall getRhsPrimaryParserRuleCall_1_2_0() { return cRhsPrimaryParserRuleCall_1_2_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.gjouneau.dsl.sat.Sat.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cNOTKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cAtomicParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Primary Expression:
		//	'(' Expression ')' | {Not} ("!" | "NOT") expression=Primary | Atomic;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Expression ')' | {Not} ("!" | "NOT") expression=Primary | Atomic
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Expression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{Not} ("!" | "NOT") expression=Primary
		public Group getGroup_1() { return cGroup_1; }
		
		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }
		
		//("!" | "NOT")
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//"!"
		public Keyword getExclamationMarkKeyword_1_1_0() { return cExclamationMarkKeyword_1_1_0; }
		
		//"NOT"
		public Keyword getNOTKeyword_1_1_1() { return cNOTKeyword_1_1_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_1_2_0() { return cExpressionPrimaryParserRuleCall_1_2_0; }
		
		//Atomic
		public RuleCall getAtomicParserRuleCall_2() { return cAtomicParserRuleCall_2; }
	}
	public class AtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.gjouneau.dsl.sat.Sat.Atomic");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Atomic Expression:
		//	{Variable} name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//{Variable} name=ID
		public Group getGroup() { return cGroup; }
		
		//{Variable}
		public Action getVariableAction_0() { return cVariableAction_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	
	
	private final ModelSATElements pModelSAT;
	private final ExpressionElements pExpression;
	private final EquivElements pEquiv;
	private final ImpliesElements pImplies;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final NandElements pNand;
	private final PrimaryElements pPrimary;
	private final AtomicElements pAtomic;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SatGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModelSAT = new ModelSATElements();
		this.pExpression = new ExpressionElements();
		this.pEquiv = new EquivElements();
		this.pImplies = new ImpliesElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pNand = new NandElements();
		this.pPrimary = new PrimaryElements();
		this.pAtomic = new AtomicElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("fr.gjouneau.dsl.sat.Sat".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//ModelSAT:
	//	{ModelSAT} (expression+=Expression (";" expression+=Expression)*)?;
	public ModelSATElements getModelSATAccess() {
		return pModelSAT;
	}
	
	public ParserRule getModelSATRule() {
		return getModelSATAccess().getRule();
	}
	
	//Expression:
	//	Equiv;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Equiv Expression:
	//	Implies ({Equiv.lhs=current} ("EQUIV" | "<=>") rhs=Implies)*;
	public EquivElements getEquivAccess() {
		return pEquiv;
	}
	
	public ParserRule getEquivRule() {
		return getEquivAccess().getRule();
	}
	
	//Implies Expression:
	//	Or ({Implies.lhs=current} ("IMPLIES" | "->") rhs=Or)*;
	public ImpliesElements getImpliesAccess() {
		return pImplies;
	}
	
	public ParserRule getImpliesRule() {
		return getImpliesAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.lhs=current} ("OR" | "||") rhs=And)*;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Expression:
	//	Nand ({And.lhs=current} ("AND" | "&&") rhs=Nand)*;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Nand Expression:
	//	Primary ({Nand.lhs=current} ("NAND" | "!&") rhs=Primary)*;
	public NandElements getNandAccess() {
		return pNand;
	}
	
	public ParserRule getNandRule() {
		return getNandAccess().getRule();
	}
	
	//Primary Expression:
	//	'(' Expression ')' | {Not} ("!" | "NOT") expression=Primary | Atomic;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//Atomic Expression:
	//	{Variable} name=ID;
	public AtomicElements getAtomicAccess() {
		return pAtomic;
	}
	
	public ParserRule getAtomicRule() {
		return getAtomicAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
