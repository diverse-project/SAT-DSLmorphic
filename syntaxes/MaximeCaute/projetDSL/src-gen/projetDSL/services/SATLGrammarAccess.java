/*
 * generated by Xtext 2.19.0
 */
package projetDSL.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SATLGrammarAccess extends AbstractGrammarElementFinder {
	
	public class BooleanExpressionsSystemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.BooleanExpressionsSystem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBooleanExpressionsSystemAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSystemeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBooleanExpressionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBooleanExpressionsBooleanExpressionParserRuleCall_3_0 = (RuleCall)cBooleanExpressionsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BooleanExpressionsSystem:
		//	{BooleanExpressionsSystem}
		//	"Systeme" '{' booleanExpressions+=BooleanExpression* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanExpressionsSystem} "Systeme" '{' booleanExpressions+=BooleanExpression* '}'
		public Group getGroup() { return cGroup; }
		
		//{BooleanExpressionsSystem}
		public Action getBooleanExpressionsSystemAction_0() { return cBooleanExpressionsSystemAction_0; }
		
		//"Systeme"
		public Keyword getSystemeKeyword_1() { return cSystemeKeyword_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//booleanExpressions+=BooleanExpression*
		public Assignment getBooleanExpressionsAssignment_3() { return cBooleanExpressionsAssignment_3; }
		
		//BooleanExpression
		public RuleCall getBooleanExpressionsBooleanExpressionParserRuleCall_3_0() { return cBooleanExpressionsBooleanExpressionParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVariableKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//Variable:
		//	"Variable" ':' name=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//"Variable" ':' name=STRING
		public Group getGroup() { return cGroup; }
		
		//"Variable"
		public Keyword getVariableKeyword_0() { return cVariableKeyword_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//name=STRING
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0() { return cNameSTRINGTerminalRuleCall_2_0; }
	}
	public class BooleanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.BooleanExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExpressionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionBasicExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BooleanExpression:
		//	"Expression" ID? '{' expression+=BasicExpression '}';
		@Override public ParserRule getRule() { return rule; }
		
		//"Expression" ID? '{' expression+=BasicExpression '}'
		public Group getGroup() { return cGroup; }
		
		//"Expression"
		public Keyword getExpressionKeyword_0() { return cExpressionKeyword_0; }
		
		//ID?
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//expression+=BasicExpression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }
		
		//BasicExpression
		public RuleCall getExpressionBasicExpressionParserRuleCall_3_0() { return cExpressionBasicExpressionParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class OperatorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.OperatorExpression");
		private final Assignment cExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExpressionBiimpliesOperatorExpressionParserRuleCall_0 = (RuleCall)cExpressionAssignment.eContents().get(0);
		
		//OperatorExpression:
		//	expression+=BiimpliesOperatorExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//expression+=BiimpliesOperatorExpression
		public Assignment getExpressionAssignment() { return cExpressionAssignment; }
		
		//BiimpliesOperatorExpression
		public RuleCall getExpressionBiimpliesOperatorExpressionParserRuleCall_0() { return cExpressionBiimpliesOperatorExpressionParserRuleCall_0; }
	}
	public class BiimpliesOperatorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.BiimpliesOperatorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftMemberAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftMemberExcludesOperatorExpressionParserRuleCall_0_0 = (RuleCall)cLeftMemberAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLessThanSignHyphenMinusGreaterThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRightMemberAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMemberExcludesOperatorExpressionParserRuleCall_1_1_0 = (RuleCall)cRightMemberAssignment_1_1.eContents().get(0);
		
		//BiimpliesOperatorExpression BooleanExpression:
		//	leftMember+=ExcludesOperatorExpression ('<->' rightMember+=ExcludesOperatorExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//leftMember+=ExcludesOperatorExpression ('<->' rightMember+=ExcludesOperatorExpression)*
		public Group getGroup() { return cGroup; }
		
		//leftMember+=ExcludesOperatorExpression
		public Assignment getLeftMemberAssignment_0() { return cLeftMemberAssignment_0; }
		
		//ExcludesOperatorExpression
		public RuleCall getLeftMemberExcludesOperatorExpressionParserRuleCall_0_0() { return cLeftMemberExcludesOperatorExpressionParserRuleCall_0_0; }
		
		//('<->' rightMember+=ExcludesOperatorExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'<->'
		public Keyword getLessThanSignHyphenMinusGreaterThanSignKeyword_1_0() { return cLessThanSignHyphenMinusGreaterThanSignKeyword_1_0; }
		
		//rightMember+=ExcludesOperatorExpression
		public Assignment getRightMemberAssignment_1_1() { return cRightMemberAssignment_1_1; }
		
		//ExcludesOperatorExpression
		public RuleCall getRightMemberExcludesOperatorExpressionParserRuleCall_1_1_0() { return cRightMemberExcludesOperatorExpressionParserRuleCall_1_1_0; }
	}
	public class ExcludesOperatorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.ExcludesOperatorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftMemberAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftMemberImpliesOperatorExpressionParserRuleCall_0_0 = (RuleCall)cLeftMemberAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLessThanSignHyphenMinusExclamationMarkGreaterThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRightMemberAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMemberImpliesOperatorExpressionParserRuleCall_1_1_0 = (RuleCall)cRightMemberAssignment_1_1.eContents().get(0);
		
		//ExcludesOperatorExpression BooleanExpression:
		//	leftMember+=ImpliesOperatorExpression ('<-!>' rightMember+=ImpliesOperatorExpression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//leftMember+=ImpliesOperatorExpression ('<-!>' rightMember+=ImpliesOperatorExpression)?
		public Group getGroup() { return cGroup; }
		
		//leftMember+=ImpliesOperatorExpression
		public Assignment getLeftMemberAssignment_0() { return cLeftMemberAssignment_0; }
		
		//ImpliesOperatorExpression
		public RuleCall getLeftMemberImpliesOperatorExpressionParserRuleCall_0_0() { return cLeftMemberImpliesOperatorExpressionParserRuleCall_0_0; }
		
		//('<-!>' rightMember+=ImpliesOperatorExpression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'<-!>'
		public Keyword getLessThanSignHyphenMinusExclamationMarkGreaterThanSignKeyword_1_0() { return cLessThanSignHyphenMinusExclamationMarkGreaterThanSignKeyword_1_0; }
		
		//rightMember+=ImpliesOperatorExpression
		public Assignment getRightMemberAssignment_1_1() { return cRightMemberAssignment_1_1; }
		
		//ImpliesOperatorExpression
		public RuleCall getRightMemberImpliesOperatorExpressionParserRuleCall_1_1_0() { return cRightMemberImpliesOperatorExpressionParserRuleCall_1_1_0; }
	}
	public class ImpliesOperatorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.ImpliesOperatorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftMemberAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftMemberOrOperatorExpressionParserRuleCall_0_0 = (RuleCall)cLeftMemberAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRightMemberAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMemberOrOperatorExpressionParserRuleCall_1_1_0 = (RuleCall)cRightMemberAssignment_1_1.eContents().get(0);
		
		//ImpliesOperatorExpression BooleanExpression:
		//	leftMember+=OrOperatorExpression ('->' rightMember+=OrOperatorExpression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//leftMember+=OrOperatorExpression ('->' rightMember+=OrOperatorExpression)?
		public Group getGroup() { return cGroup; }
		
		//leftMember+=OrOperatorExpression
		public Assignment getLeftMemberAssignment_0() { return cLeftMemberAssignment_0; }
		
		//OrOperatorExpression
		public RuleCall getLeftMemberOrOperatorExpressionParserRuleCall_0_0() { return cLeftMemberOrOperatorExpressionParserRuleCall_0_0; }
		
		//('->' rightMember+=OrOperatorExpression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_0() { return cHyphenMinusGreaterThanSignKeyword_1_0; }
		
		//rightMember+=OrOperatorExpression
		public Assignment getRightMemberAssignment_1_1() { return cRightMemberAssignment_1_1; }
		
		//OrOperatorExpression
		public RuleCall getRightMemberOrOperatorExpressionParserRuleCall_1_1_0() { return cRightMemberOrOperatorExpressionParserRuleCall_1_1_0; }
	}
	public class OrOperatorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.OrOperatorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftMemberAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftMemberAndOperatorExpressionParserRuleCall_0_0 = (RuleCall)cLeftMemberAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cOuKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRightMemberAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMemberAndOperatorExpressionParserRuleCall_1_1_0 = (RuleCall)cRightMemberAssignment_1_1.eContents().get(0);
		
		//OrOperatorExpression BooleanExpression:
		//	leftMember+=AndOperatorExpression ('ou' rightMember+=AndOperatorExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//leftMember+=AndOperatorExpression ('ou' rightMember+=AndOperatorExpression)*
		public Group getGroup() { return cGroup; }
		
		//leftMember+=AndOperatorExpression
		public Assignment getLeftMemberAssignment_0() { return cLeftMemberAssignment_0; }
		
		//AndOperatorExpression
		public RuleCall getLeftMemberAndOperatorExpressionParserRuleCall_0_0() { return cLeftMemberAndOperatorExpressionParserRuleCall_0_0; }
		
		//('ou' rightMember+=AndOperatorExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'ou'
		public Keyword getOuKeyword_1_0() { return cOuKeyword_1_0; }
		
		//rightMember+=AndOperatorExpression
		public Assignment getRightMemberAssignment_1_1() { return cRightMemberAssignment_1_1; }
		
		//AndOperatorExpression
		public RuleCall getRightMemberAndOperatorExpressionParserRuleCall_1_1_0() { return cRightMemberAndOperatorExpressionParserRuleCall_1_1_0; }
	}
	public class AndOperatorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.AndOperatorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftMemberAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftMemberNegOperatorExpressionParserRuleCall_0_0 = (RuleCall)cLeftMemberAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cEtKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRightMemberAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMemberNegOperatorExpressionParserRuleCall_1_1_0 = (RuleCall)cRightMemberAssignment_1_1.eContents().get(0);
		
		//AndOperatorExpression BooleanExpression:
		//	leftMember+=NegOperatorExpression ('et' rightMember+=NegOperatorExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//leftMember+=NegOperatorExpression ('et' rightMember+=NegOperatorExpression)*
		public Group getGroup() { return cGroup; }
		
		//leftMember+=NegOperatorExpression
		public Assignment getLeftMemberAssignment_0() { return cLeftMemberAssignment_0; }
		
		//NegOperatorExpression
		public RuleCall getLeftMemberNegOperatorExpressionParserRuleCall_0_0() { return cLeftMemberNegOperatorExpressionParserRuleCall_0_0; }
		
		//('et' rightMember+=NegOperatorExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'et'
		public Keyword getEtKeyword_1_0() { return cEtKeyword_1_0; }
		
		//rightMember+=NegOperatorExpression
		public Assignment getRightMemberAssignment_1_1() { return cRightMemberAssignment_1_1; }
		
		//NegOperatorExpression
		public RuleCall getRightMemberNegOperatorExpressionParserRuleCall_1_1_0() { return cRightMemberNegOperatorExpressionParserRuleCall_1_1_0; }
	}
	public class NegOperatorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.NegOperatorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNegatedMemberAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNegatedMemberBasicExpressionParserRuleCall_1_0 = (RuleCall)cNegatedMemberAssignment_1.eContents().get(0);
		
		//NegOperatorExpression BooleanExpression:
		//	'non'? negatedMember+=BasicExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'non'? negatedMember+=BasicExpression
		public Group getGroup() { return cGroup; }
		
		//'non'?
		public Keyword getNonKeyword_0() { return cNonKeyword_0; }
		
		//negatedMember+=BasicExpression
		public Assignment getNegatedMemberAssignment_1() { return cNegatedMemberAssignment_1; }
		
		//BasicExpression
		public RuleCall getNegatedMemberBasicExpressionParserRuleCall_1_0() { return cNegatedMemberBasicExpressionParserRuleCall_1_0; }
	}
	public class BasicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "projetDSL.SATL.BasicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cVariableVariableParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOperatorExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorExpressionOperatorExpressionParserRuleCall_1_1_0 = (RuleCall)cOperatorExpressionAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//BasicExpression BooleanExpression:
		//	variable+=Variable |
		//	'(' operatorExpression+=OperatorExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//variable+=Variable | '(' operatorExpression+=OperatorExpression ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//variable+=Variable
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//Variable
		public RuleCall getVariableVariableParserRuleCall_0_0() { return cVariableVariableParserRuleCall_0_0; }
		
		//'(' operatorExpression+=OperatorExpression ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//operatorExpression+=OperatorExpression
		public Assignment getOperatorExpressionAssignment_1_1() { return cOperatorExpressionAssignment_1_1; }
		
		//OperatorExpression
		public RuleCall getOperatorExpressionOperatorExpressionParserRuleCall_1_1_0() { return cOperatorExpressionOperatorExpressionParserRuleCall_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	
	
	private final BooleanExpressionsSystemElements pBooleanExpressionsSystem;
	private final VariableElements pVariable;
	private final BooleanExpressionElements pBooleanExpression;
	private final OperatorExpressionElements pOperatorExpression;
	private final BiimpliesOperatorExpressionElements pBiimpliesOperatorExpression;
	private final ExcludesOperatorExpressionElements pExcludesOperatorExpression;
	private final ImpliesOperatorExpressionElements pImpliesOperatorExpression;
	private final OrOperatorExpressionElements pOrOperatorExpression;
	private final AndOperatorExpressionElements pAndOperatorExpression;
	private final NegOperatorExpressionElements pNegOperatorExpression;
	private final BasicExpressionElements pBasicExpression;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SATLGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pBooleanExpressionsSystem = new BooleanExpressionsSystemElements();
		this.pVariable = new VariableElements();
		this.pBooleanExpression = new BooleanExpressionElements();
		this.pOperatorExpression = new OperatorExpressionElements();
		this.pBiimpliesOperatorExpression = new BiimpliesOperatorExpressionElements();
		this.pExcludesOperatorExpression = new ExcludesOperatorExpressionElements();
		this.pImpliesOperatorExpression = new ImpliesOperatorExpressionElements();
		this.pOrOperatorExpression = new OrOperatorExpressionElements();
		this.pAndOperatorExpression = new AndOperatorExpressionElements();
		this.pNegOperatorExpression = new NegOperatorExpressionElements();
		this.pBasicExpression = new BasicExpressionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("projetDSL.SATL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//BooleanExpressionsSystem:
	//	{BooleanExpressionsSystem}
	//	"Systeme" '{' booleanExpressions+=BooleanExpression* '}';
	public BooleanExpressionsSystemElements getBooleanExpressionsSystemAccess() {
		return pBooleanExpressionsSystem;
	}
	
	public ParserRule getBooleanExpressionsSystemRule() {
		return getBooleanExpressionsSystemAccess().getRule();
	}
	
	//Variable:
	//	"Variable" ':' name=STRING;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//BooleanExpression:
	//	"Expression" ID? '{' expression+=BasicExpression '}';
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return pBooleanExpression;
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}
	
	//OperatorExpression:
	//	expression+=BiimpliesOperatorExpression;
	public OperatorExpressionElements getOperatorExpressionAccess() {
		return pOperatorExpression;
	}
	
	public ParserRule getOperatorExpressionRule() {
		return getOperatorExpressionAccess().getRule();
	}
	
	//BiimpliesOperatorExpression BooleanExpression:
	//	leftMember+=ExcludesOperatorExpression ('<->' rightMember+=ExcludesOperatorExpression)*;
	public BiimpliesOperatorExpressionElements getBiimpliesOperatorExpressionAccess() {
		return pBiimpliesOperatorExpression;
	}
	
	public ParserRule getBiimpliesOperatorExpressionRule() {
		return getBiimpliesOperatorExpressionAccess().getRule();
	}
	
	//ExcludesOperatorExpression BooleanExpression:
	//	leftMember+=ImpliesOperatorExpression ('<-!>' rightMember+=ImpliesOperatorExpression)?;
	public ExcludesOperatorExpressionElements getExcludesOperatorExpressionAccess() {
		return pExcludesOperatorExpression;
	}
	
	public ParserRule getExcludesOperatorExpressionRule() {
		return getExcludesOperatorExpressionAccess().getRule();
	}
	
	//ImpliesOperatorExpression BooleanExpression:
	//	leftMember+=OrOperatorExpression ('->' rightMember+=OrOperatorExpression)?;
	public ImpliesOperatorExpressionElements getImpliesOperatorExpressionAccess() {
		return pImpliesOperatorExpression;
	}
	
	public ParserRule getImpliesOperatorExpressionRule() {
		return getImpliesOperatorExpressionAccess().getRule();
	}
	
	//OrOperatorExpression BooleanExpression:
	//	leftMember+=AndOperatorExpression ('ou' rightMember+=AndOperatorExpression)*;
	public OrOperatorExpressionElements getOrOperatorExpressionAccess() {
		return pOrOperatorExpression;
	}
	
	public ParserRule getOrOperatorExpressionRule() {
		return getOrOperatorExpressionAccess().getRule();
	}
	
	//AndOperatorExpression BooleanExpression:
	//	leftMember+=NegOperatorExpression ('et' rightMember+=NegOperatorExpression)*;
	public AndOperatorExpressionElements getAndOperatorExpressionAccess() {
		return pAndOperatorExpression;
	}
	
	public ParserRule getAndOperatorExpressionRule() {
		return getAndOperatorExpressionAccess().getRule();
	}
	
	//NegOperatorExpression BooleanExpression:
	//	'non'? negatedMember+=BasicExpression;
	public NegOperatorExpressionElements getNegOperatorExpressionAccess() {
		return pNegOperatorExpression;
	}
	
	public ParserRule getNegOperatorExpressionRule() {
		return getNegOperatorExpressionAccess().getRule();
	}
	
	//BasicExpression BooleanExpression:
	//	variable+=Variable |
	//	'(' operatorExpression+=OperatorExpression ')';
	public BasicExpressionElements getBasicExpressionAccess() {
		return pBasicExpression;
	}
	
	public ParserRule getBasicExpressionRule() {
		return getBasicExpressionAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
