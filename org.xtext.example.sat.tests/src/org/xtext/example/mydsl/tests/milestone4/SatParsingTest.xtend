/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl.tests.milestone4

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.xtext.example.mydsl.sat.Expression
import org.xtext.example.mydsl.tests.SatInjectorProvider
import java.util.HashMap
import org.xtext.example.mydsl.sat.And
import org.xtext.example.mydsl.sat.Not
import org.xtext.example.mydsl.sat.Or
import org.xtext.example.mydsl.sat.BiImpl
import org.xtext.example.mydsl.sat.Impl
import org.xtext.example.mydsl.sat.Nand
import java.nio.file.Files
import java.nio.file.Paths
import org.xtext.example.mydsl.sat.Sat
import org.xtext.example.mydsl.sat.DimacsFile
import org.xtext.example.mydsl.sat.Model
import java.io.FileWriter
import java.io.File
import org.xtext.example.mydsl.sat.SATSolverMethod
import java.io.BufferedReader
import java.io.InputStreamReader
import org.sat4j.specs.ISolver
import org.sat4j.minisat.SolverFactory
import org.sat4j.reader.Reader
import org.sat4j.reader.DimacsReader
import java.io.PrintWriter
import org.sat4j.specs.IProblem
import java.io.FileNotFoundException

@ExtendWith(InjectionExtension)
@InjectWith(SatInjectorProvider)
class SatParsingTest {
	@Inject
	ParseHelper<Sat> parseHelper
	
	@Test
	def void main() {
		var String inputFileName = "test.sat";
		var String outputDimacsFileName = "test.cnf";
		
		var String content = new String(Files.readAllBytes(Paths.get(inputFileName)));
		
		var Sat sat = parseHelper.parse(content);
		var String dimacs;
		if (sat.getType() instanceof Model) {
			dimacs = getDIMACSFromInlineFormula(sat.getType() as Model);
		} else if (sat.getType() instanceof DimacsFile) {
			dimacs = getDIMACSFromFile(sat.getType() as DimacsFile);
		}
		
		println(dimacs);
		var FileWriter writer = new FileWriter(new File(outputDimacsFileName));
		writer.write(dimacs);
		writer.close();
		
		var SATSolverMethod solverMethod = sat.getSolver_method();
		switch solverMethod
		{
			case SATSolverMethod.SAT4J_JAVA:
			{
				var ISolver solver = SolverFactory.newDefault();
		        solver.setTimeout(3600); // 1 hour timeout
		        var Reader reader = new DimacsReader(solver);
		        var PrintWriter out = new PrintWriter(System.out, true);
		        // CNF filename is given on the command line 
		        try {
		            var IProblem problem = reader.parseInstance(outputDimacsFileName);
		            if (problem.isSatisfiable()) {
		                System.out.println("Satisfiable !");
		                reader.decode(problem.model(), out);
		            } else {
		                System.out.println("Unsatisfiable !");
		            }
		        } catch (Exception e) {
		            System.out.println("Oops!");      
		        }
		        out.close();
			}
			
			case SATSolverMethod.SAT4J_JAR:
			{
				var Process p = Runtime.getRuntime().exec("java -jar org.sat4j.core.jar " + outputDimacsFileName);
				
				var BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
				
				var String s = null;
				while ((s = stdInput.readLine()) !== null) {
				    System.out.println(s);
				}
			}
			
			case SATSolverMethod.SAT4J_MAVEN:
			{}
		}
	}
	
	def String getDIMACSFromInlineFormula(Model model)
	{
		var Expression ast = model.getModel()
		ast.prettyPrint;
		println();
		
		var HashMap<String, Integer> literal_ids = new HashMap<String, Integer>();
		ast.parse_cnf_literals(literal_ids);
		return ast.toDIMACS(literal_ids);
	}
	
	def String getDIMACSFromFile(DimacsFile file)
	{
		return new String(Files.readAllBytes(Paths.get(file.getFilepath())));
	}
	
	def parse_cnf_literals(Expression e, HashMap<String, Integer> literal_ids) {
		if(e.getId() !== null)
		{
			if(!literal_ids.containsKey(e.getId()))
				literal_ids.put(e.getId(), literal_ids.size() + 1); 
		} else if(e instanceof And) {
			e.getLeft().parse_cnf_literals(literal_ids);
			e.getRight().parse_cnf_literals(literal_ids);
		} else if (e instanceof Not) {
			e.getExpression().parse_cnf_literals(literal_ids);
		} else if (e instanceof Or) {
			e.getLeft().parse_cnf_literals(literal_ids);
			e.getRight().parse_cnf_literals(literal_ids);
		} 		
	}
	
	def count_cnf_clause(Expression e) {
		var Expression current = e;
		var int count = 1;
		while(current instanceof And)
		{
			count++;
			current = current.getLeft();
		}
		return count;
	}
	
	def cnfToDIMACS(Expression e, HashMap<String, Integer> literal_ids) {
		if (e instanceof Or) {
			return(e.getLeft().cnfToDIMACS(literal_ids) + " " + e.getRight().cnfToDIMACS(literal_ids));
		} else if(e instanceof And) {
			return(e.getRight().cnfToDIMACS(literal_ids) + " 0\n" + e.getLeft().cnfToDIMACS(literal_ids));
		} else if (e instanceof Not) {
			return("-" + literal_ids.get(e.getExpression().getId()));
		} else if(e.getId() !== null) {
			return(literal_ids.get(e.getId()));
		}
	}
		
	
	def String toDIMACS(Expression e, HashMap<String, Integer> literal_ids) '''
		p cnf «literal_ids.size()» «e.count_cnf_clause»
		«e.cnfToDIMACS(literal_ids)» 0
	'''
	// -> print right with printclause
	//
	// -> parse the left
	// while we find a ^ we printclause the right
	// if we don't find a ^ we printclause the current expression
	
	def prettyPrint(And e) {
		print("(");
		e.getLeft().prettyPrint;
		print(" ^ ")
		e.getRight().prettyPrint;
		print(")");
	}
	
	def prettyPrint(BiImpl e) {
		print("(");
		e.getLeft().prettyPrint;
		print(" <=> ")
		e.getRight().prettyPrint;
		print(")");
	}
	
	def prettyPrint(Impl e) {
		print("(");
		e.getLeft().prettyPrint;
		print(" => ")
		e.getRight().prettyPrint;
		print(")");
	}
	
	def prettyPrint(Nand e) {
		print("(");
		e.getLeft().prettyPrint;
		print(" | ")
		e.getRight().prettyPrint;
		print(")");
	}
	
	def prettyPrint(Not e) {
		print("~");
		e.getExpression().prettyPrint;
	}
	
	def prettyPrint(Or e) {
		print("(");
		e.getLeft().prettyPrint;
		print(" v ")
		e.getRight().prettyPrint;
		print(")");
	}
	
	def prettyPrint(Expression e) {
		if(e instanceof And) {
			prettyPrint(e as And);
		} else if (e instanceof BiImpl) {
			prettyPrint(e as BiImpl);	
		} else if (e instanceof Impl) {
			prettyPrint(e as Impl);	
		} else if (e instanceof Nand) {
			prettyPrint(e as Nand);
		} else if (e instanceof Not) {
			prettyPrint(e as Not);
		} else if (e instanceof Or) {
			prettyPrint(e as Or);
		} else if(e.getId() !== null) {
			print(e.getId());
		}
	}

	
	@Test
	def void loadModel() {
		val result = parseHelper.parse('''
			A v B => C
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
		
		println("model=" + result)
	}
}
