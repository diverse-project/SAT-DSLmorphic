/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SatGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSolverKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSolverAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSolverSolverEnumRuleCall_1_0 = (RuleCall)cSolverAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cExpressionBiImplParserRuleCall_2_0_0 = (RuleCall)cExpressionAssignment_2_0.eContents().get(0);
		private final Assignment cFileAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cFileFileParserRuleCall_2_1_0 = (RuleCall)cFileAssignment_2_1.eContents().get(0);
		
		//Model:
		//	'solver' solver=Solver (expression=BiImpl | file=File);
		@Override public ParserRule getRule() { return rule; }
		
		//'solver' solver=Solver (expression=BiImpl | file=File)
		public Group getGroup() { return cGroup; }
		
		//'solver'
		public Keyword getSolverKeyword_0() { return cSolverKeyword_0; }
		
		//solver=Solver
		public Assignment getSolverAssignment_1() { return cSolverAssignment_1; }
		
		//Solver
		public RuleCall getSolverSolverEnumRuleCall_1_0() { return cSolverSolverEnumRuleCall_1_0; }
		
		//(expression=BiImpl | file=File)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//expression=BiImpl
		public Assignment getExpressionAssignment_2_0() { return cExpressionAssignment_2_0; }
		
		//BiImpl
		public RuleCall getExpressionBiImplParserRuleCall_2_0_0() { return cExpressionBiImplParserRuleCall_2_0_0; }
		
		//file=File
		public Assignment getFileAssignment_2_1() { return cFileAssignment_2_1; }
		
		//File
		public RuleCall getFileFileParserRuleCall_2_1_0() { return cFileFileParserRuleCall_2_1_0; }
	}
	public class FileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.File");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPathAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathSTRINGTerminalRuleCall_1_0 = (RuleCall)cPathAssignment_1.eContents().get(0);
		
		//File:
		//	'file' path=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//'file' path=STRING
		public Group getGroup() { return cGroup; }
		
		//'file'
		public Keyword getFileKeyword_0() { return cFileKeyword_0; }
		
		//path=STRING
		public Assignment getPathAssignment_1() { return cPathAssignment_1; }
		
		//STRING
		public RuleCall getPathSTRINGTerminalRuleCall_1_0() { return cPathSTRINGTerminalRuleCall_1_0; }
	}
	public class BiImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.BiImpl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImplParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBiImplLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightImplParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BiImpl Expression:
		//	Impl ({BiImpl.left=current} '<=>' right=Impl)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Impl ({BiImpl.left=current} '<=>' right=Impl)*
		public Group getGroup() { return cGroup; }
		
		//Impl
		public RuleCall getImplParserRuleCall_0() { return cImplParserRuleCall_0; }
		
		//({BiImpl.left=current} '<=>' right=Impl)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BiImpl.left=current}
		public Action getBiImplLeftAction_1_0() { return cBiImplLeftAction_1_0; }
		
		//'<=>'
		public Keyword getLessThanSignEqualsSignGreaterThanSignKeyword_1_1() { return cLessThanSignEqualsSignGreaterThanSignKeyword_1_1; }
		
		//right=Impl
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Impl
		public RuleCall getRightImplParserRuleCall_1_2_0() { return cRightImplParserRuleCall_1_2_0; }
	}
	public class ImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.Impl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImplLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Impl Expression:
		//	Or ({Impl.left=current} '=>' right=Or)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({Impl.left=current} '=>' right=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({Impl.left=current} '=>' right=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Impl.left=current}
		public Action getImplLeftAction_1_0() { return cImplLeftAction_1_0; }
		
		//'=>'
		public Keyword getEqualsSignGreaterThanSignKeyword_1_1() { return cEqualsSignGreaterThanSignKeyword_1_1; }
		
		//right=Or
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Or
		public RuleCall getRightOrParserRuleCall_1_2_0() { return cRightOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.left=current} 'v' right=And)*;
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} 'v' right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} 'v' right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'v'
		public Keyword getVKeyword_1_1() { return cVKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNandParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightNandParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Expression:
		//	Nand ({And.left=current} '^' right=Nand)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Nand ({And.left=current} '^' right=Nand)*
		public Group getGroup() { return cGroup; }
		
		//Nand
		public RuleCall getNandParserRuleCall_0() { return cNandParserRuleCall_0; }
		
		//({And.left=current} '^' right=Nand)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1_1() { return cCircumflexAccentKeyword_1_1; }
		
		//right=Nand
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Nand
		public RuleCall getRightNandParserRuleCall_1_2_0() { return cRightNandParserRuleCall_1_2_0; }
	}
	public class NandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.Nand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNandLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cVerticalLineKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cUpwardsArrowKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Nand Expression:
		//	Primary ({Nand.left=current} ('|' | '↑') right=Primary)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({Nand.left=current} ('|' | '↑') right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({Nand.left=current} ('|' | '↑') right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Nand.left=current}
		public Action getNandLeftAction_1_0() { return cNandLeftAction_1_0; }
		
		//('|' | '↑')
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//'|'
		public Keyword getVerticalLineKeyword_1_1_0() { return cVerticalLineKeyword_1_1_0; }
		
		//'↑'
		public Keyword getUpwardsArrowKeyword_1_1_1() { return cUpwardsArrowKeyword_1_1_1; }
		
		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cBiImplParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cNotParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVarParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Primary Expression:
		//	'(' BiImpl ')' | Not | Const | Var;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' BiImpl ')' | Not | Const | Var
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' BiImpl ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//BiImpl
		public RuleCall getBiImplParserRuleCall_0_1() { return cBiImplParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//Not
		public RuleCall getNotParserRuleCall_1() { return cNotParserRuleCall_1; }
		
		//Const
		public RuleCall getConstParserRuleCall_2() { return cConstParserRuleCall_2; }
		
		//Var
		public RuleCall getVarParserRuleCall_3() { return cVarParserRuleCall_3; }
	}
	public class NotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.Not");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cTildeKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Action cNotExpressionAction_2 = (Action)cGroup.eContents().get(2);
		
		//Not Expression:
		//	('!' | '~') Primary {Not.expression=current};
		@Override public ParserRule getRule() { return rule; }
		
		//('!' | '~') Primary {Not.expression=current}
		public Group getGroup() { return cGroup; }
		
		//('!' | '~')
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_0_0() { return cExclamationMarkKeyword_0_0; }
		
		//'~'
		public Keyword getTildeKeyword_0_1() { return cTildeKeyword_0_1; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_1() { return cPrimaryParserRuleCall_1; }
		
		//{Not.expression=current}
		public Action getNotExpressionAction_2() { return cNotExpressionAction_2; }
	}
	public class VarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.Var");
		private final Assignment cIdAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdIDTerminalRuleCall_0 = (RuleCall)cIdAssignment.eContents().get(0);
		
		//Var Expression:
		//	id=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//id=ID
		public Assignment getIdAssignment() { return cIdAssignment; }
		
		//ID
		public RuleCall getIdIDTerminalRuleCall_0() { return cIdIDTerminalRuleCall_0; }
	}
	public class ConstElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.Const");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cValAlternatives_0 = (Alternatives)cValAssignment.eContents().get(0);
		private final Keyword cValTrueKeyword_0_0 = (Keyword)cValAlternatives_0.eContents().get(0);
		private final Keyword cValFalseKeyword_0_1 = (Keyword)cValAlternatives_0.eContents().get(1);
		
		//Const Expression:
		//	val=("true" | "false");
		@Override public ParserRule getRule() { return rule; }
		
		//val=("true" | "false")
		public Assignment getValAssignment() { return cValAssignment; }
		
		//("true" | "false")
		public Alternatives getValAlternatives_0() { return cValAlternatives_0; }
		
		//"true"
		public Keyword getValTrueKeyword_0_0() { return cValTrueKeyword_0_0; }
		
		//"false"
		public Keyword getValFalseKeyword_0_1() { return cValFalseKeyword_0_1; }
	}
	
	public class SolverElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Sat.Solver");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSAT4J_JAVAEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSAT4J_JAVASat4jJavaKeyword_0_0 = (Keyword)cSAT4J_JAVAEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSAT4J_JAREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSAT4J_JARSat4jJarKeyword_1_0 = (Keyword)cSAT4J_JAREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cSAT4J_COMPEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cSAT4J_COMPSat4jMavenKeyword_2_0 = (Keyword)cSAT4J_COMPEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum Solver:
		//	SAT4J_JAVA="sat4j-java" | SAT4J_JAR="sat4j-jar" | SAT4J_COMP="sat4j-maven";
		public EnumRule getRule() { return rule; }
		
		//SAT4J_JAVA="sat4j-java" | SAT4J_JAR="sat4j-jar" | SAT4J_COMP="sat4j-maven"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SAT4J_JAVA="sat4j-java"
		public EnumLiteralDeclaration getSAT4J_JAVAEnumLiteralDeclaration_0() { return cSAT4J_JAVAEnumLiteralDeclaration_0; }
		
		//"sat4j-java"
		public Keyword getSAT4J_JAVASat4jJavaKeyword_0_0() { return cSAT4J_JAVASat4jJavaKeyword_0_0; }
		
		//SAT4J_JAR="sat4j-jar"
		public EnumLiteralDeclaration getSAT4J_JAREnumLiteralDeclaration_1() { return cSAT4J_JAREnumLiteralDeclaration_1; }
		
		//"sat4j-jar"
		public Keyword getSAT4J_JARSat4jJarKeyword_1_0() { return cSAT4J_JARSat4jJarKeyword_1_0; }
		
		//SAT4J_COMP="sat4j-maven"
		public EnumLiteralDeclaration getSAT4J_COMPEnumLiteralDeclaration_2() { return cSAT4J_COMPEnumLiteralDeclaration_2; }
		
		//"sat4j-maven"
		public Keyword getSAT4J_COMPSat4jMavenKeyword_2_0() { return cSAT4J_COMPSat4jMavenKeyword_2_0; }
	}
	
	private final ModelElements pModel;
	private final SolverElements eSolver;
	private final FileElements pFile;
	private final BiImplElements pBiImpl;
	private final ImplElements pImpl;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final NandElements pNand;
	private final PrimaryElements pPrimary;
	private final NotElements pNot;
	private final VarElements pVar;
	private final ConstElements pConst;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SatGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.eSolver = new SolverElements();
		this.pFile = new FileElements();
		this.pBiImpl = new BiImplElements();
		this.pImpl = new ImplElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pNand = new NandElements();
		this.pPrimary = new PrimaryElements();
		this.pNot = new NotElements();
		this.pVar = new VarElements();
		this.pConst = new ConstElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.mydsl.Sat".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	'solver' solver=Solver (expression=BiImpl | file=File);
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//enum Solver:
	//	SAT4J_JAVA="sat4j-java" | SAT4J_JAR="sat4j-jar" | SAT4J_COMP="sat4j-maven";
	public SolverElements getSolverAccess() {
		return eSolver;
	}
	
	public EnumRule getSolverRule() {
		return getSolverAccess().getRule();
	}
	
	//File:
	//	'file' path=STRING;
	public FileElements getFileAccess() {
		return pFile;
	}
	
	public ParserRule getFileRule() {
		return getFileAccess().getRule();
	}
	
	//BiImpl Expression:
	//	Impl ({BiImpl.left=current} '<=>' right=Impl)*;
	public BiImplElements getBiImplAccess() {
		return pBiImpl;
	}
	
	public ParserRule getBiImplRule() {
		return getBiImplAccess().getRule();
	}
	
	//Impl Expression:
	//	Or ({Impl.left=current} '=>' right=Or)*;
	public ImplElements getImplAccess() {
		return pImpl;
	}
	
	public ParserRule getImplRule() {
		return getImplAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.left=current} 'v' right=And)*;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Expression:
	//	Nand ({And.left=current} '^' right=Nand)*;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Nand Expression:
	//	Primary ({Nand.left=current} ('|' | '↑') right=Primary)*;
	public NandElements getNandAccess() {
		return pNand;
	}
	
	public ParserRule getNandRule() {
		return getNandAccess().getRule();
	}
	
	//Primary Expression:
	//	'(' BiImpl ')' | Not | Const | Var;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//Not Expression:
	//	('!' | '~') Primary {Not.expression=current};
	public NotElements getNotAccess() {
		return pNot;
	}
	
	public ParserRule getNotRule() {
		return getNotAccess().getRule();
	}
	
	//Var Expression:
	//	id=ID;
	public VarElements getVarAccess() {
		return pVar;
	}
	
	public ParserRule getVarRule() {
		return getVarAccess().getRule();
	}
	
	//Const Expression:
	//	val=("true" | "false");
	public ConstElements getConstAccess() {
		return pConst;
	}
	
	public ParserRule getConstRule() {
		return getConstAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
